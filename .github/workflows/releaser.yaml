name: Release

on:
  workflow_run:
    workflows: ["CI"] # name of the build/test workflow that must finish successfully
    types:
      - completed
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'If set to true, goreleaser will run in snapshot mode and ko will not push'
        required: false
        default: 'true'

permissions:
  id-token: write
  contents: write
  packages: write

jobs:
  goreleaser:
    runs-on: blacksmith-2vcpu-ubuntu-2204
    outputs:
      version: ${{ steps.tag.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0
          fetch-tags: true

      - name: Verify tag commit is on main
        run: |
          git fetch origin main
          if git branch --remote --contains ${{ github.event.workflow_run.head_sha }} | grep -q "origin/main"; then
            echo "Tag commit is contained in main – proceeding with release."
          else
            echo "Tag commit is NOT contained in main. Aborting release."
            exit 1
          fi

      - name: Extract tag
        id: tag
        run: |
          tag=$(git describe --tags --exact-match)
          echo "version=$tag" >> "$GITHUB_OUTPUT"

      - name: Check if release already published
        id: release_check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG:      ${{ steps.tag.outputs.version }}
        run: |
          code=$(curl -s -o /dev/null -w "%{http_code}" \
                 -H "Authorization: Bearer $GH_TOKEN" \
                 -H "Accept: application/vnd.github+json" \
                 https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG)
          if [ "$code" = "200" ]; then
            echo "exists=true"  >> "$GITHUB_OUTPUT"
            echo "Release $TAG already exists – skipping artefact build."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "No release yet for $TAG – continuing."
          fi
      
      - name: Inspect OIDC token
        if: steps.release_check.outputs.exists == 'false'
        run: |
          raw=$(curl -s "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=sts.amazonaws.com" \
                    -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN")
            echo "$raw" | jq -R 'split(".") | .[1] | @base64d | fromjson'
      
      - name: Configure AWS credentials for S3 upload
        if: steps.release_check.outputs.exists == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set up Go
        if: steps.release_check.outputs.exists == 'false'
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Import GPG key
        if: steps.release_check.outputs.exists == 'false'
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase:      ${{ secrets.GPG_PASSPHRASE }}

      - name: Cache go modules
        if: steps.release_check.outputs.exists == 'false'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ${{ env.GOMODCACHE }}
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Run GoReleaser
        if: steps.release_check.outputs.exists == 'false' && inputs.dry_run != 'true'
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SHOULD_UPDATE_BREW: "true"
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
      
      - name: Skip – release already present
        if: steps.release_check.outputs.exists == 'true'
        run: echo "✔︎ Nothing to do – assets are already on GitHub."
  image:
    needs: goreleaser
    runs-on: blacksmith-2vcpu-ubuntu-2204
    permissions:
      id-token: write
      contents: read
      packages: write
    env:
      VERSION:        ${{ needs.goreleaser.outputs.version }}
      KO_PLATFORMS:   linux/amd64,linux/arm64
      KO_DOCKER_REPO: ghcr.io/nirmata/kyverno-mcp
    steps:
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0

      - name: Install ko CLI
        uses: ko-build/setup-ko@v0.6
          
      - name: Check if GHCR image already exists
        id: imgcheck
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO:     ${{ github.repository }}
          TAG:      ${{ env.VERSION }}
        run: |
          repo_path="${REPO,,}"                    
          code=$(curl -s -o /dev/null -w "%{http_code}" \
                 -I \
                 -H "Authorization: Bearer $GH_TOKEN" \
                 -H "Accept: application/vnd.oci.image.manifest.v1+json" \
                 https://ghcr.io/v2/${repo_path}/manifests/${TAG})
          
          if [ "$code" = "200" ]; then
            echo "exists=true"  >> "$GITHUB_OUTPUT"
            echo "Image ghcr.io/${repo_path}:${TAG} already present – skipping build."
          elif [[ "$code" == 401 || "$code" == 404 ]]; then
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "No image for tag $TAG yet – will build & push."
          else
            echo "Unexpected registry response: $code" >&2
            exit 1
          fi

      - name: Authenticate to GHCR
        if: steps.imgcheck.outputs.exists == 'false'
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | 
          ko login ghcr.io --username ${{ github.actor }} --password-stdin

      - name: Build + push multi-arch image with ko
        if: steps.imgcheck.outputs.exists == 'false' && inputs.dry_run != 'true'
        run: |
          ko build ./cmd \
            --platform="${KO_PLATFORMS}" \
            --tags "latest,${VERSION}" \
            --sbom=cyclonedx \
            --bare \
            --push
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign the pushed image (key-less OIDC workflow)
        if: steps.imgcheck.outputs.exists == 'false' && github.event.workflow_run.conclusion == 'success'
        run: |
          IMAGE="ghcr.io/${{ github.repository }}:${{ env.VERSION }}"
          cosign sign --yes "$IMAGE"